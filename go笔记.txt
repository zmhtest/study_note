GO语言教程--腾讯

安装：

配置环境变量：
	GOROOT 	go的安装目录
	GOPATH 	项目的位置，该目录下有src、bin目录
	%GOPATH%\bin 	添加到环境变量中 	
	%GOROOT%\bin 	

编译：在哪个目录下运行 go build helloworld 
	  就会在哪个目录下生成编译后的文件
	  
	go install helloworld
	
一个go程序的目录结构：
	 GO--项目目录
		├─bin 编译（go install）后.exe文件的默认位置，如果不设置GOBIN就用此位置
		└─src 源码的位置
			└─helloworld 包，下面有 main.go 文件

启动一个本地的文档服务器：
	PS D:\WWW\go> godoc.exe -http=:9090
	浏览器输入：localhost:9090 即可访问
	
在vs code中安装go插件，运行 go install 即会在 GOPATH 目录的bin和src目录生成相应的工具！！！

基础知识：
	package hello

	import (
	//引入包
		"fmt"
		"runtime"
		"math"
	)

	//整个go程序的入口
	func main() {
	
		fmt.Println("hello 世界")

		// 属性或方法的导出，首字母必须大写
		fmt.Println(math.Pi)

	}

	定义函数，需要声明参数类型和返回值类型
	如果所有的参数类型都一样，只需在最后一个参数注明类型即可
	func add(x ,y int) int {
		
		return x+y
	}

	多值返回
	func add(x,y int) (int,int) {
		return x+2,y+3;
	}

	命名返回，x y 在函数返回时声明了，所以函数内部不需要声明
	也就是说，函数内部必须也要用 x y表示
	func test1(sum int)(x,y int) {
		x = sum+1
		y = sum -1
		return  
	}

	func main() {
	
		函数测试
		fmt.Println(add(12,12))

		声明变量的两种方法
		var 语句定义了一个变量的列表；
		跟函数的参数列表一样，类型在后面。
		var a,b int = add(2,2)

		短声明变量
		在函数中可以使用 `:=` 声明，但在函数外不可以，必须用 var
		a,b := add(2,3)

		fmt.Println(a,b)

		fmt.Println(test1(10))

	}

	func main() {

		// 不换行输出
		fmt.Print("Go runs on ")
		
		// 先计算，在执行条件判断
		switch os := runtime.GOOS; os {
		
			//switch 的条件从上到下的执行，当匹配成功的时候停止
			case "darwin":
				fmt.Println("OS X.")
			
			case "linux":
				fmt.Println("Linux.")
			
			default:
				fmt.Printf("%s.", os)
		}

	}

	//defer 语句会延迟函数的执行直到上层函数返回。
	func main() {
		defer fmt.Println("world")

		fmt.Println("hello")
	}

	func main() {
		fmt.Println("counting")

		for i := 0; i < 10; i++ {
			defer fmt.Println(i)
		}

		fmt.Println("done")
	}

	// 延迟的函数调用被压入一个栈中。当函数返回时，
	// 会按照后进先出的顺序调用被延迟的函数调用


包详解：
任何的go文件都属于一个特定的包：
	1.同一个包下面，不同文件内的变量、函数，可以在直接访问。
	注意：需要编译之后，将多个文件绑定在一起才能访问，单个运行是会报错的！！！
	
	2.不同包的文件中的变量，需要引入这个包，才能访问到变量或者函数。
	
go中不允许有多余的包引入，在保存时，会自动取出多余的引入！！！

注意：小写字母开头的函数或者变量，表示私有，只能在本包内部访问，如果在其他包访问，会报错：
	src\day1\eg1\main.go:13:2: cannot refer to unexported name eg12.add

当没有导入相应的包，报错如下：
	src\day1\eg1\main.go:3:1: syntax error: non-declaration statement outside function body

package的命名，每个包文件夹下面除了main包的所有的文件中，都必须：package folderName
否则go会找不到包！！！

总结：无论包放在哪里都可以通过正确的 import 得到！！！
	
	1.main包内部：
		main函数所在文件，可以直接访问；
		同级的文件内部，也可以直接访问
	
	2.定义在main包文件夹内部的包
	
	3.定义在main包同级的包
	
	4.定义在main包上一级的包
	
	5.定义在GOPATH\src的包

	import "day1/eg1/inside" 这个路径是相对 src 的路径！！！
	
	可以给引入的包设置别名 ,一旦起了别名，就一定要通过别名调用！！！
	import(
		in "day1/eg1/inside"
	)

每个包中都有一个 init 方法，该方法会在引入包时自动执行，可以用来初始化一些变量！！！

	package eg12

	var Name string
	var Age int

	func init() {
		Name = "朱明浩"
		Age = 23
	}

如果只是想在 main 中引入包时进行初始化而不是要调用，可以在import中加入 _
	import _ "day1/eg12"

函数的可变参数：放在参数列表的最后， arg... int

	func add(a int, args ...int) int {
	sum := a
	for i := 0; i < len(args); i++ {
		sum += args[i]
	}
	return sum
	}

	func main() {
		sum := add(10, 20, 30)
		fmt.Println(sum)
	}

常量与变量
	常量的声明：
	const(
		Man = 1
		Female = -1
	)
	
	变量的声明：
	1、只声明，不赋值，会有默认值 1 '' false
	var(
		a int
		b string
		c bool
	)
	
	2.声明类型，并赋值
	var(
		d int = 12
		e string = "hello"
	)	
	
	3.直接赋值
	var(
		d = 12
		e = "hello"
	)
	
	4.函数内部
		d := 12
		
基本数据类型：int string array struct float	bool
引用类型：指针、slice、chan、map

// 变量的引用类型

	func modify(a int) {
		a = 10
		return
	}
	
	func modify1(a *int) {
		*a = 10
		return
	}

	func main() {
		var a = 5

		// modify(a)
		// fmt.Println(a)

		modify1(&a)
		fmt.Println(a)
	}

通过指针来交换变量的值
	func swap(a, b *int) {
	var tmp = *a
	*a = *b
	*b = tmp
	return
	}
	
	func main() {
		var a = 3
		var b = 4
		fmt.Println(a)
		fmt.Println(b)

		swap(&a, &b)
		fmt.Println(a)
		fmt.Println(b)
	}

生成随机数：要用到随机种子 time.now().unixNano

	func init() {
		rand.Seed(time.Now().UnixNano())
	}
	
	func main() {
		for i := 0; i < 10; i++ {
			a := rand.Int()
			fmt.Println(a)
		}
	}	

// fmt详解

	func main() {
	
		var a = 97
		var b bool
		c := 'a'
		d := "hello"
		e :=123.456

		fmt.Printf("%v\n", a)    //97 值的默认格式
		fmt.Printf("%#v\n", b)   //false 值的go语法表示
		fmt.Printf("%v\n", c)    //97 
		fmt.Printf("%T\n", c)    //int32 值的类型的go语法表示
		fmt.Printf("%T\n", d)    //string 
		fmt.Printf("%s\n", d)    //hello 打印字符串
		fmt.Printf("%q\n", d)    //"hello" 引号包围字符串
		fmt.Printf("%f\n", e)    //123.456000 浮点数，末尾补0
		fmt.Printf("%g\n", e)    //123.456 浮点数原样输出
		fmt.Printf("%G\n", e)    //123.456
		fmt.Printf("%e\n", e)    //1.234560e+02 科学计数法
		fmt.Printf("%E\n", e)    //1.234560E+02
		fmt.Printf("%d%%\n", 90) //90% %%相当于%
		fmt.Printf("90%%\n")     //90%
		fmt.Printf("%t\n", b)    //false 布尔：true、false
		fmt.Printf("%c\n", a)    //a ASCII对应的字符
		fmt.Printf("%b\n", a)    //1100001 二进制表示
		fmt.Printf("%o\n", a)    //141 八进制表示
		fmt.Printf("%x\n", a)    //61 十六进制表示
		fmt.Printf("%q\n", 97)    //'a' 单引号包围的字符字面值
		fmt.Printf("%p\n", &a)   //0xc042056058 打印地址值

	}

	func main() {

		var a int
		var b int
		fmt.Scanf("%d%d", &a, &b)
		fmt.Println(a, b)
	}

// 接收控制台输入,输出一个范围内的所有素数
	func isPrime(n int) bool {
		for i := 2; i < n; i++ {
			if n%i == 0 {
				return false
			}
		}
		return true
	}
	func main() {

		var a int
		var b int
		fmt.Scanf("%d%d", &a, &b)

		for i := a; i < b; i++ {

			if isPrime(i) {
				fmt.Println(i)
			}
		}

		fmt.Println(a, b)
	}

//水仙花数，每位数的3次方之和==该数

	func isNum(n int) bool {
		var i, j, k int
		i = n % 10
		j = (n / 10) % 10
		k = (n / 100) % 10

		sum := i*i*i + j*j*j + k*k*k

		return sum == n
	}

	func main() {
		var n, m int
		fmt.Scanf("%d%d", &n, &m)

		for i := n; i < m; i++ {

			if isNum(i) {
				fmt.Println(i)
			}

		}
	}

// 求一个数的阶乘之和，分两步，求一个数的 阶乘，放到for循环，求和
//两个for循环，其实可以合并！！！
	func jiecheng(n int) int {
		var res int = 1
		var sum = 0
		for i := 1; i <= n; i++ {
			res = res * i
			sum += res
		}
	
		return sum
	}

	func main() {
		var n int
		fmt.Scanf("%d", &n)

		var sum int	
		sum = jiecheng(n)

		fmt.Println(sum)
	}




学习进度：第四节

























GO-无闻

go原生支持utf8

PS C:\Users\Administrator> godoc fmt Println

安装：gosublime插件

变量的定义：
	函数内部不能通过 var()的方法设置变量，函数外部必须使用var声明变量。

可以使用type()设置类型别名

	func main() {
		type (
			str string
		)
	
		var name str = "朱明浩"
		fmt.Printf("%v", name)
		fmt.Printf("%T", name) //main.str
	}
	
strconv的基本使用
	func main() {
		var a = 65
		// b := string(a) A
		// b := strconv.Itoa(a) 65
		c := strconv.Itoa(a) //int转字符串
		d, err := strconv.Atoi("12a3") //字符串型的数字转int
		if err != nil {//如果有错误信息则会执行
			panic(err)
		}

		fmt.Println(c, d)

	}

常量的定义：

	const(
		PI = 3.14
	)
	
常量的值在编译时就已经确定，
等号右侧必须是常量或者常量表达式，
常量表达式中的函数必须是内置函数，

_表示可以不接受一个值
	a,_,c,d := 1,2,3,4
它的作用：函数有多个返回值，而我们只想取出我们所需要的返回值！！！

_ 在import中表示，只初始化这个包的init方法，这个包的其他方法不可以在当前包中访问，也就不会报 “引入却没有使用的错误"

. 在import中使用，可以实现在该文件中直接使用这个包里面的方法，而不用加包前缀！！
但是，非常不建议使用，影响代码的可读性。

位运算符：& | ^ &^
	运算方法：先将操作数全部转为二进制
	比如： 6 11
		0110
		1011

	&	0010 2
	|	1111 15
	^	1101 13 异或运算，不同才返回1
	&^  0100 4  右边操作数 1 ，左边对应位变为0
	
利用左移和iota实现计算机的进制转换 B KB MB GB

	const (
		B float64 = 1 << (iota * 10)
		KB
		MB
		GB
	)

	func main() {
		fmt.Println(KB)
		fmt.Println(MB / KB)
		fmt.Println(GB / MB)
	}
	
变量指针
	func main() {
		i := 10
		i++ //++、--只能放在变量右边，且必须独占一行
		fmt.Println(i) //11

		var p *int = &i
		*p = 20         //通过指针改变该地址对应的值
		fmt.Println(p)  //0xc042056058
		fmt.Println(*p) //20
		fmt.Println(i)  //20
	}
		
条件判断if,条件部分强制不能使用 ()	

	初始化语句中的变量，只能在if中使用，是局部变量。
	func main() {
		a := 10
		//一行中有多条语句用 ; 隔开
		if a := 2; a > 0 { //左大括号必须和if放在同一行
			a = 3 //改变局部变量的值
			fmt.Println(a)//3
		}
		fmt.Print(a)//10
	}
	
使用编辑器，保存代码时，会自动格式化代码，非常实用！！！

循环：
	1.无限循环
		a:=1
		for{
			if a>3 {
				break
			}
			fmt.Println(a)
			a++
		}
		
	2.普通for循环
		func main() {

			for a := 1; a <= 3; a++ {

				fmt.Println(a)
			}
		}
记住：不要将条件表达式放在循环语句中，提高效率

	a := "string"
	for i:=0;i<len(a);i++{} //这是不推荐的做法

switch语句	
	/*func main() {

		for a := 1; a <= 3; a++ {

			fmt.Println(a)
		}
	}*/
	func main() {

		a := 0
		switch a {
		case 0:
			fmt.Println("a=0")
			// fallthrough
		case 1:
			fmt.Println("a=1")
		default:
			fmt.Println("a=2")

		}

		a := 2
		switch {
		case a > 0:
			fmt.Println("a>0")
			// fallthrough
		case a > 1:
			fmt.Println("a>1")
		}

		switch a := 2; {//a只在switch内有效
		case a > 0:
			fmt.Println("a>0")
			// fallthrough
		case a > 1:
			fmt.Println("a>1")
		}
	}

跳转关键字
	func main() {
	LABEL1:
		for {
			for i := 0; i < 10; i++ {
				fmt.Println(i)

				if i > 5 {
					// break //只是跳出当前循环，外面还是循环，死循环
					break LABEL1
				}
				// fmt.Println(i)
			}
		}
	}	
	
	func main() {

		for {
			for i := 0; i < 10; i++ {
				fmt.Println(i)

				if i > 5 {
					goto LABEL1
				}
				// fmt.Println(i)
			}
		}
		LABEL1://如果使用goto,一定要把标签放在for循环最后，否则又是进入死循环！！！
	}
	
	func main() {
		LABEL1:
		for i := 0; i < 10; i++ {
			fmt.Println(i)
			for {
				fmt.Println("continue")
				continue LABEL1 //跳出label1的当次循环，继续执行下一次外层循环
				//此处，如果换成goto,程序只是跳到label1，从头开始执行，每次都是从头开始，陷入死循环
			}
		}
	}	
	
数组的定义
	func main() {
		var a [2]int
		a := [2]int{1, 2} //[1 2] 按顺序依次赋值
		a := [2]int{1} //[1 0]
		a := [5]int{4: 1} //[0 0 0 0 1] 只设置下标为 4 的值，其他为默认值
		a := [...]int{1, 2, 3} //[1 2 3]
		a := [...]int{1: 2, 2: 3, 3: 4} //[0 2 3 4]
		a := [...]int{5: 1} //[0 0 0 0 0 1] 自动创建6个元素的数组，下标为5的值为1
		fmt.Println(a) //[0 0]
	}	
	
数组的指针和指针数组：注意 * 的位置！！！
	// 数组的指针
	func main() {
		a := [...]int{99: 1}
		var p *[100]int = &a

		fmt.Println(p)
	}

	// 指针数组，数组的元素都是指针
	func main() {

		x, y := 10, 12
		a := [...]*int{&x, &y}

		fmt.Println(a) //[0xc042056058 0xc042056070]
	}	
	
GO中的数组是值类型，而不像其他语言上的引用类型

数组直接的比较 == !=

	注意：a := [2]int; b := [3]int 是属于不同的类型，不能用于比较。
	长度也是数组类型的一部分
	
	func main() {
		a := [2]int{1, 2}
		b := [2]int{1, 2}
		c := [2]int{2, 1}
		fmt.Println(a == b) //true
		fmt.Println(a == c) //false
		fmt.Println(a != c) //true
		//当两个数组完全相等才为true，也就是元素的个数、顺序、值完全相等
	}
	
数组的赋值和new方法声明数组
	func main() {
		a := [3]int{} //声明一个空数组
		var a [3]int //声明一个空数组

		a[1] = 2
		fmt.Println(a) //[0 2 0]

		b := new([3]int) //返回数组的指针
		b[1] = 2
		fmt.Println(b) //&[0 2 0]

	}
	
多维数组，在多维数组中也可以使用一维数组的规则
	func main() {

		a := [2][3]int{ //[一维][二维]
			{0: 4, 1: 5, 2: 6}, //指定索引赋值
			{1, 2, 3}}          //右大括号必须在同一行

		fmt.Println(a) //[[1 2 3] [4 5 6]]

		// 访问二维数组的元素
		fmt.Println(a[0][1]) //5

		// 遍历二维数组的所有元素
		l1 := len(a)
		for i := 0; i < l1; i++ {

			l2 := len(a[i])
			for j := 0; j < l2; j++ {
				fmt.Println(a[i][j])
			}

		}

	}	
	
冒泡排序
	func main() {
		a := [...]int{1, 6, 2, 4, 3, 11, 22}

		// 循环遍历数组
		l := len(a)
		for i := 0; i < l; i++ {

			// 依次和i后面一个数比较
			for j := i + 1; j < l; j++ {
			
			//只需改变 > < 即可实现升降序排列
				if a[i] > a[j] {
					tmp := a[i]
					a[i] = a[j]
					a[j] = tmp
				}
			}
		}
		fmt.Println(a)
	}	
	
切片

	func main() {

		1直接定义一个切片
		var sl []int
		
		创建切片，并初始化
		sl := []int{1, 2, 3, 4}
		fmt.Println(sl) //[1 2 3 4]
		fmt.Println(len(sl), cap(sl)) //4 4 

		2通过数组组装切片
		a := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
		sl := a[5:] //[5,6 7 8 9 ]
		sl := a[5:8] //[5 6 7 ]
		sl := a[:5] //[0 1 2 3 4]

	3.使用make方法定义，数组的底层就是一块连续的内存空间
	参数2：切片的长度 ；
	参数3：切片底层数组的容量
	当切片长度超出，底层数组容量时，数组容量会翻倍 20 40
		sl := make([]int, 3, 10) //[0 0 0]
		sl[0] = 1 //[1 0 0] 给切片赋值

		fmt.Println(len(sl), cap(sl)) //3 10 如果没有制定 cap,值为切片长度
		fmt.Println(sl)

		a := [...]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'}
		sa := a[2:5]  //[99 100 101]
		sb := sa[1:3] //[100 101] 重新切片，基于sa进行切片，

		fmt.Println(len(a))           //11
		fmt.Println(len(sa), cap(sa)) //3 9
		fmt.Println(len(sb), cap(sb)) //2 8

		sc := sa[3:5] //[102 103] 并不会越界！！！
		fmt.Println(sc)

	}

append新元素到切片
	func main() {

		sl := make([]int, 3, 6)
		fmt.Printf("%p\n", sl) //0xc042008270
		fmt.Println(sl)        //[0 0 0]

		sl = append(sl, 1, 2, 3)
		fmt.Println(sl)               //[0 0 0 1 2 3]
		fmt.Println(len(sl), cap(sl)) //6 6
		fmt.Printf("%p\n", sl)        //0xc042008270 没超数组容量，地址不变

		sl = append(sl, 4, 5, 6)
		fmt.Println(sl)               //[0 0 0 1 2 3 4 5 6]
		fmt.Println(len(sl), cap(sl)) //9 12 容量翻倍
		fmt.Printf("%p\n", sl)        //0xc042048060 切片过长，开辟新的内存，返回新的地址
	}	
	
slice指向底层的数组，所以，如果由数组衍生出来的其中一个 slice 改变了值，也就是改变了数组相应位置元素的值，那么其他slice的值也会相应发生改变！！！

注意：如果衍生的slice通过append()追加元素，导致超出slice的容量时，生成一个新的数组，新的slice，容量加倍，所以，其他slice对数组的改变不会影响到新的slice！！！

copy(sa,sb) 将sb复制到sa
如果长度相等，就是完全覆盖
如果 sa>sb,sb覆盖sa的前部分 
如果 sa<sb,sb的前一部分完全覆盖sa，元素个数为sa原来的个数	
	
map：类似其他语言的hash表，key->value，但是key必须是不可变的类型，map的效率比slice要低。


    func main() {
        1.声明一个键类型为int，值类型为string的map
        var m map[int]string
        初始化为一个空map
        m = map[int]string{}

        2.声明并初始化
        m := map[int]string{}
        fmt.Println(m) //map[]

        3.使用make方法
        m := make(map[int]string)
        m[1] = "朱明浩"

        // 给map赋值
        m[1] = "朱明浩"
        m[2] = "朱明强"
        fmt.Println(m) //map[1:朱明浩]
        fmt.Println(m[2]) //朱明强

    }	

// 数组和map的迭代操作，相当于foreach
注意：
    func main() {

        a := [...]int{1, 23, 3, 4, 5, 6}

        sl := a[2:5]

        m := make(map[int]string)
        m[1] = "hello"
        m[2] = "hello2"
        m[3] = "hello3"

        for i, v := range a {
            fmt.Println(i, v)
        }
        fmt.Println("----------")

        for i, v := range sl {
            fmt.Println(i, v)
        }
        fmt.Println("----------")

        for k, v := range m {
            fmt.Println(k, v)
        }
    }
        
对键值对的操作只是对副本的操作，如果要修改数组或map，可以使用索引或者key！！！    
slice和map的复合操作
    func main() {
        sl := make([]map[int]string, 5)
        
        for _, v := range sl {
            v = make(map[int]string, 1)
            v[1] = "hello"
            fmt.Println(v)
        }
        fmt.Println(sl) //[map[] map[] map[] map[] map[]]

        for i := range sl {
            sl[i] = make(map[int]string, 1)
            sl[i][1] = "ok"
        }
        fmt.Println(sl) //[map[1:ok] map[1:ok] map[1:ok] map[1:ok] map[1:ok]]

    }   
    
  在go中一切皆类型，函数也是类型，同样支持匿名函数。
  
交换 map的键值对
    func main() {
        m1 := map[int]string{1: "a", 2: "b", 3: "c"}

        // var m2 = make(map[string]int)
        
        // m2 := make(map[string]int)
        //make方法具有声明类型并初始化的作用，
        
        // m2 := map[string]int{} //如果没有make，需要手动加 {} 初始化

        for k, v := range m1 {

            m2[v] = k
        }
        // 注意：map是乱序的，每次打印顺序都不一样！！！
        fmt.Println(m1) //map[2:b 3:c 1:a]
        fmt.Println(m2) //map[a:1 b:2 c:3]
    }  
        
匿名函数、变量函数        
    func main() {

        //匿名函数
        a := func() {
            fmt.Println("hello china")
        }
        a()

        // 函数赋给变量，变量函数
        b := B
        b()
    }

    func B() {
        fmt.Println("hello B")
    }  

剩余参数，保存在一个slice中
    func main() {
        a, b := 1, 2

        A(a, b)
        fmt.Println(a, b) // 1 2

    }

    func A(a ...int) {

        a[0] = 3
        a[1] = 4

        fmt.Println(a) //[3 4] 多余的参数以数组的形式保存，它是复制一份，并不影响本身
    }
        
 
函数的参数传递，如果传一个 slice,函数内部改变了slice，将会改变slice本身！！！
    func main() {
    
        sl := []int{1, 2, 3}

        A(sl)
        fmt.Println(sl) //[4 5 6]

    }

    func A(s []int) {
        s[0] = 4
        s[1] = 5
        s[2] = 6
        fmt.Println(s) //[4 5 6]
    }

// go中的闭包
    func main() {

        f := closure(10) //0xc042056058
        fmt.Println(f(1)) //0xc042056058 11
        fmt.Println(f(2)) //0xc042056058 12
    // 闭包函数closure执行完后，它内部的变量并不会马上释放

    }

    func closure(x int) func(int) int {
        fmt.Printf("%p\n", &x)
        return func(y int) int {
            fmt.Printf("%p\n", &x)
            return x + y
        }
    }

如果想通过闭包改变外部函数的值呢？
内外函数中，地址都相同，直接改就行了！！！
    func main() {
        f := closure()
        fmt.Println(f()) //1
        fmt.Println(f()) //2
        fmt.Println(f()) //3

    }

    func closure() func() int {
        x := 0
        return func() int {
            x++
            return x
        }
    }

defer 相当于折构函数，函数执行完后，逆向执行所有的defer语句
    func main() {
        defer fmt.Println("a")
        defer fmt.Println("b")
        defer fmt.Println("c")
    }
    结果 ：c b a

    func main() {
        for i := 0; i < 5; i++ {
            defer fmt.Println(i)
        }
    }
    结果：4 3 2 1 0
    
    func main() {
    
        for i := 0; i < 3; i++ {
    
            defer func() {
                fmt.Println(i) // 3 3 3 解释：相当于闭包，main函数执行完后，执行defer，此时 i 值已经为3
            }()// 直接调用匿名函数
        }
    }

go中的异常处理机制：没有try catch，只有panic和recover，recover只能在defer中执行，并且要在panic之前。
当程序执行到panic就退出，不在往下执行！！！

    func main() {

        A()
        B()
        C()
        // 结果：A, recover in B , C
    }

    func A() {
    
        fmt.Println("A")
    }
    
    func B() {
    
        defer func() {
        
            如果程序没有发生 panic，recover()函数的返回值为nil
            if err := recover(); err != nil {
            
                fmt.Println("recover in B")
                fmt.Println(err) //panic in B ，如果程序发生panic，recover()函数返回panic中的信息

            }
        }()
        
        panic("panic in B")
    }
    
    func C() {
    
        fmt.Println("C")
    }

只要在匿名函数中使用该函数中没有的变量，往往是闭包，这个变量就是外层结构执行完后的最终值，比如：如果是for循环，那么i就是i最后的值！

    func main() {

        fs := [3]func(){} //定义一个函数类型

        for i := 0; i < 3; i++ {

            defer fmt.Println(i)

            defer func() {
                fmt.Printf("defer_i:%d\n", i)
            }()

            fs[i] = func() { fmt.Printf("closure_i:%d\n", i) }
        }

        for _, f := range fs {
            f()
        }
    }

结构体

    type test struct{}

    // 相当于定义一个类
    type person struct {
        Name string
        Age  int
    }

    func main() {

        a := test{} //{} 空的结构体
        fmt.Println(a)

        相当于实例化对象
        可以用键值对进行初始化
        p := person{
            Name: "朱杏梓",
            Age:  8, //这里的 , 不可忽略
        } 
        fmt.Println(p) //{朱杏梓 8}

        p := person{} 
        相当于给对象设置属性
        p.Name = "朱明浩"
        p.Age = 23
        fmt.Println(p) //{朱明浩 23}

    }

特殊的结构体：匿名结构体、匿名字段结构体

    func main() {

        // 初始化结构体，以指针方式
        //如果不是以指针的方式传参，将是拷贝副本，并不影响原本！！！
        p := &Person{
            Name: "朱明浩",
            Age:  23,
        }

        // 把结构体的指针传到函数，结果是改变结构体本身
        
        A(p)
        B(p)

        fmt.Println(p.Name, p.Age) //24
    }

    func A(per *Person) {
        per.Age = 22
        fmt.Println(per.Name, per.Age)
    }

    func B(per *Person) {
        per.Age = 24
        fmt.Println(per.Name, per.Age)
    }

匿名结构体
     func main() {

     //省略了type struct_name
     //直接声明，赋值，如果需要指针传参 *struct{}{}即可
        a := struct {
            Name string
            Age  int
        }{
            Name: "朱明浩",
            Age:  23,
        }

        fmt.Println(a.Name, a.Age)
    }
    
匿名字段结构体
    func main() {

        a := struct {
            string //不能声明多个string
            int
        }{
            "朱明浩", //顺序如果不对应是会报错的！！！
            23,
        }

        fmt.Println(a) //{朱明浩 23}
    }   
    
结构体的嵌套
    type Person struct {
    
        Name    string
        Age     int
        Contact struct {
            phone, City string
        }
    }

    func main() {
    
        p := Person{
            Name: "朱明浩",
            Age:  23,
        }
        
        p.Contact.phone = "1234565"
        p.Contact.City = "GaoZhou"

        fmt.Println(p) //{朱明浩 23 {1234565 GaoZhou}}
    }    
  
结构体类型的赋值、比较,只有同样的类型才能进行互相赋值和比较
    func main() {

        a := Person{
            Name: "朱明浩",
            Age:  23,
        }

        // b := a //把a赋给b，a、b类型和值完全一样
        var b Person
        b = a
        fmt.Println(b)
        fmt.Println(b == a) //true
    }

结构体复用：    
    type Human struct {
        sex int
    }

    type male struct {
        sex int
    }
    
    type teacher struct {
        Human
        male
        name string
        age  int
    }


    func main() {

        // 初始化
        t := teacher{
            name:  "teacher",
            age:   30,
            Human: Human{sex: 1}, //特别注意
        }

        // 取值和修改值
        t.name = "老师"
        t.age = 32

        // t.sex = 10 //没有歧义的情况下可以这样用
        
        t.Human.sex = 10        //保留这种写法的原因：如果不同的结构体有相同的属性，就可以通过结构体名加以区分

        fmt.Println(t.Human.sex) //10 
        fmt.Println(t.teacher.sex) // 0 
    }

方法method
    type Person struct{}

    func main() {

        p := Person{}

        p.print()
    }

    // 定义一个方法，通过接收者和结构体绑定
    func (p *Person) print() {
        fmt.Println("Person")
    }

通过method丰富普通类型的功能
    type TY int

    func main() {
        var num TY
        fmt.Println(num) //0
        num.increase(10)
        fmt.Println(num) //10
    }

    //说明，可以通过method给所有的类型进行重新封装赋予新的功能
    func (n *TY) increase(x int) {

        *n += TY(x) //这里必须进行类型转换
    }

接口：定义了一些抽象的方法，没有方法体，需要构造体来实现接口的所有方法，
才能通过接口来调用构造体的方法

    type USB interface {
    
        Name() string //接口定义方法和返回值
        Connect()
    }

    // 这个结构体要实现USB接口的所有方法
    type phone struct {
    
        name string //相当于定义属性，用于Name()返回
    }
    
    通过method给phone结构体绑定方法
    func (p phone) Name() string {

        return p.name
    }

    func (p phone) Connect() {

        fmt.Println("connected", p.name)
    }

    func main() {
    
        // var usb USB
        // usb = phone{name: "iPhone"} //结构体实现了接口的所有方法，所以可以赋给接口

        usb := phone{"iphone6s"} //可以按照顺序赋值，不用写 key

        fmt.Println(usb.Name()) // iPhone 通过接口访问phone构造体实现的方法
        usb.Connect()           //connected iPhone

        Disconnect(usb) //usb为phone结构体，也可以调用函数成功，说明这个结构体实现了USB接口的所有方法
    }

    声明一个函数，只能接受USB类型
    func Disconnect(usb USB) {
	//这里要求传入的是一个USB，如何获得传入的结构体的name呢？
        if p, ok := usb.(phone); ok {
        
            fmt.Println(ok) //true

            fmt.Println("disconnected", p.name)
            return
        }
        fmt.Println("unknow device.")
    }

空接口是所有类型的顶级接口，可以认为所有的类型都实现了空接口，又有一些其他的方法！！！

接口之间也是可以相互转换的，但，只能降级转换！！！

空接口，允许传入任意类型
    func Disconnect(usb interface{}) {

        switch v := usb.(type) {
        case phone:
            fmt.Println("disconnected", v.name)
        default:
            fmt.Println("unknow device.")

        }
    }

反射配合interface{}
可以极大提高程序的灵活性

反射
    type User struct {
        Id   int
        Name string
        Age  int
    }

    func (u User) Hello() { //注意：如果是小写，接口里是访问不到的！！！
        fmt.Println("hello world")

    }

    func info(o interface{}) {
        t := reflect.TypeOf(o)
        fmt.Printf("%v\n", t) //main.User
        // fmt.Println("type:", t.Name()) //接口的名称

        v := reflect.ValueOf(o) //实现接口的类型的值的集合
        fmt.Printf("%v", v)//{1 朱明浩 23}

        fmt.Println("Fields:")

        for i := 0; i < t.NumField(); i++ {
            //结构体的每个键值对下标索引从0开始
            f := t.Field(i)               //接口是根据索引来存字段的
            val := v.Field(i).Interface() //取出接口的值
            fmt.Printf("%s: %v = %v\n", f.Name, f.Type, val)

        }

        for i := 0; i < t.NumMethod(); i++ {
            m := t.Method(i) 
            fmt.Printf("%s:%v\n", m.Name, m.Type)//Hello:func(main.User)

        }

    }

    func main() {

        u := User{1, "朱明浩", 23}
        info(u)
    }

通过反射改变结构体的值
    type User struct {
        Id   int
        Name string
        Age  int
    }

    func main() {
        u := User{1, "朱杏梓", 23}
        fmt.Println(u) //{1 朱杏梓 23}
        Set(&u) //{1 朱明浩 23}
        fmt.Println(u)
    }

    func Set(o interface{}) {
    
    //  先取得传进来的结构体的值
        v := reflect.ValueOf(o)

        // 判断传进来的是否是指针，只有传进来的是指针才能调用 v.Elem()方法
        if v.Kind() != reflect.Ptr || !v.Elem().CanSet() {
            fmt.Println("xxx")
            return
        } else {
            v = v.Elem()
        }
        
        f := v.FieldByName("Name") //根据字段名取出

        //判断字段的有效性
        if !f.IsValid() {
            fmt.Println("BAD")
            return
        }

        // 判断是否为string，因为不同的类型有不同的设置方法
        if f.Kind() == reflect.String {
            f.SetString("朱明浩")
        }
    }

通过反射来调用方法：
    type User struct {
        Id   int
        Name string
        Age  int
    }

    func (u User) Hello(name string) {
        fmt.Print("hello ", name, ",my name is ", u.Name) //WhelloBob,my name is joe
    }

    func main() {
        u := User{1, "joe", 23}
        // u.Hello("Bob")

        // 反射实现
        v := reflect.ValueOf(u)
        um := v.MethodByName("Hello")

        args := []reflect.Value{reflect.ValueOf("Bob")} //声明参数数组，值为Bob

        um.Call(args) //传参调用方法 hello Bob,my name is joe

    }

并发：

    func Go() {
        fmt.Println("ggg")
    }

    func main() {
        go Go() //由于并发，main函数继续往下执行，很快就结束了，所以看不到输出
        time.Sleep(2 * time.Second)

    }

    func main() {

        // 如何让main函数知道并发的线程结束了呢？
        // 答：通过通信来实现

        c := make(chan bool)
        go func() {
            fmt.Println("go go go ")
            c <- true

        }()

        <-c //main函数运行到这里，阻塞，等待 go 执行完，在再往下执行
    }

    // 对channel进行迭代

    func main() {
        c := make(chan bool) //双向通道，可存可取
        go func() {
            fmt.Println("go go go ")
            c <- true
            close(c)
        }()

        // 执行过程：在对channel迭代的过程中，先会等待chanel的值，知道channel被关闭才会继续往下执行
        // 如果在程序中没有关闭channel就会形成一个死锁，程序退出!
        for v := range c {
            fmt.Println(v) //true

        }
    }

    // 测试有没缓存的区别：
    func main() {

        c := make(chan bool)
        go func() {
            fmt.Println("go go go ")
            <-c

        }()

        c <- true
    }

---------------------------

无闻web基础
    简单的http请求
    package main

    import (
        "io"
        "net/http"
        "time"
    )
//version1
    /* func main() {
        http.HandleFunc("/", SayHello)
        http.ListenAndServe(":80", nil)

    }

    func SayHello(w http.ResponseWriter, r *http.Request) {

        io.WriteString(w, "hello version1")
    }*/

// version2

    /*func main() {
        mux := http.NewServeMux()
        mux.Handle("/", &myhandel{}) //类似beego的写法
        mux.HandleFunc("/hello", sayhello)
        http.ListenAndServe(":90", mux) //这里一定要传我们自定义的服务器处理程序，而不能使用默认的 ！！！

    }

    type myhandel struct{}

    // 自定义的handel必须实现Serve HTTP才能实现http请求！！！
    func (*myhandel) ServeHTTP(w http.ResponseWriter, r *http.Request) {

        io.WriteString(w, "version 2 url:"+r.URL.String())
    }

    func sayhello(w http.ResponseWriter, r *http.Request) {

        io.WriteString(w, "hello version2")
    }*/

    // version 3 自己实现server的底层
    // 定义一个map，保存 url和相应处理方法的对应关系，并且声明了map的值为函数，还指定了函数的参数类型
    var mux map[string]func(http.ResponseWriter, *http.Request)

    func main() {
        server := http.Server{
            Addr:        ":80",
            Handler:     &myhandler{},
            ReadTimeout: 5 * time.Second,
        }

        //初始化map
        mux = make(map[string]func(http.ResponseWriter, *http.Request))
        mux["/hello"] = hello //下面要实现这两个函数
        mux["/bye"] = bye

        server.ListenAndServe()

    }

    type myhandler struct{}

    // 所有的请求都会调用Handler中的ServeHTTP方法
    func (*myhandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
        // 判断请求的url是否在map中注册，如果有，ok返回true，然后直接调用，从而将结果返回给浏览器
        if h, ok := mux[r.URL.String()]; ok {
            h(w, r)
            return
        }

    }

    // 实现处理函数
    func hello(w http.ResponseWriter, r *http.Request) {
        io.WriteString(w, "hello version3")
    }
    func bye(w http.ResponseWriter, r *http.Request) {
        io.WriteString(w, "bye bye version3")
    }

// 静态文件托管

    func main() {

        wd, err := os.Getwd()
        fmt.Println(wd)
        if err != nil {
            log.Fatal(err)
        }
        // 注意：这里必须是 /static/才会显示下级目录及文件内容！！！！
        http.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir(wd))))

        // 如果有static目录呢？
            http.Handle("/static/", http.FileServer(http.Dir(wd)))
        
        err1 := http.ListenAndServe(":90", nil) //这里一定要传我们自定义的服务器处理程序，而不能使用默认的 ！！！
        if err1 != nil {
            log.Fatal(err)
        }
    }
    
使用模板

更多有关模板的知识：https://gowalker.org/text/template
1.输出模板到控制台
    package main

    import (
        "html/template"
        "log"
        "os"
    )

    // 注意：结构体的命名要首字母大写
    type Package struct {
        Name string
        Age  int
        Sex  string
    }

    func main() {
        // New：给模板起名字，Parse()中的 内容才是模板的内容 . 表示变量的根
        tmpl, err := template.New("go-web").Parse(`my name is {{.Name}},I am {{.Age}} years old`)
        // tmpl, err := template.New("go-web").Parse(`my name is {{.Name}},I am {{.Age}} years old`)

        // tmpl, err := template.New("go-web").Parse(`{{.}}`)

        // 通过range遍历列表
        // tmpl, err := template.New("go-web").Parse(`{{range .}} {{.}} {{end}}`)

        // tmpl, err := template.New("go-web").Parse(`{{.a}} {{.b}} {{.c}}`)
        if err != nil {
            log.Fatalf("pase:%v", err)
        }

        // 这里可以继续使用err，相当于重新赋值，而不能用 := 这是声明的方法！！！
        // 函数的第二个参数是给模板中传递的变量
        // err = tmpl.Execute(os.Stdout, struct { //在控制台输出处理后模板 os.Stdout
        // 	Name string
        // 	Age  int
        // 	sex  string
        // }{"朱明浩", 23, "male"})
        err = tmpl.Execute(os.Stdout, &Package{"朱明浩", 23, "male"})
        // err = tmpl.Execute(os.Stdout, []string{"apple", "banana", "orange"})
        // err = tmpl.Execute(os.Stdout, map[string]string{"a": "apple", "b": "banana", "c": "orange"})
        if err != nil {
            log.Fatalf("execute:%v", err) //
        }
    }

2.通过http输出模板到浏览器
    Method: {{.Method}} <br>
    rawpath: {{.URL.Path}}<br>
    header: {{.Header}}<br>
    调用方法打印User-Agent: {{.Header.Get "User-Agent"}}<br>
  模板注释：{{/*注释部分*/}}  

如果想传多个变量到模板中，最好的做法是：传一个map[string]interface{}{} 

    err = tmpl.Execute(w, map[string]interface{}{
        "name": "朱明浩",
        "age":  23,
        "sex":  "male",
    })
        
    <body>
        {{.name}}
        {{.age}}
        {{.sex}}
    </body>
    
模板中的条件判断：

    num, _ := strconv.Atoi(r.FormValue("score"))
    err = tmpl.Execute(w, num)
    注意：通过r.FormValue("score")返回的是字符串，需要转化成int才能进行比较！！！

    score: {{.}} <br>
    {{if ge . 90}}
        A
    {{else if ge . 70}}
        B
    {{else if ge . 60}}
        c
    {{else}}
        D
    {{end}}
    
比较符号：
eq =
ne != 
lt <
le <=
gt >
ge >=
奇怪的是，操作符在两个操作数之前！！！    

模板中的迭代输出range：
    {{range $key,$value := .Header}}
        {{$key}}:<br>{{range $value}}{{.}}{{end}} <br><br>
    {{end}}

模板中的with：省略相同的部分
    {{with .URL}}
        {{.Host}}
        {{.Path}}
        {{.RawPath}}
    {{end}}

定义字模板
    <body>
        {{template "test"}}
    </body>
    </html>
    {{define "test"}}
        this is test
    {{end}}

beego中的模板引擎
参考网址：
https://beego.me/docs/mvc/view/tutorial.md

修改模板标签
beego.TemplateLeft = "<<<"
beego.TemplateRight = ">>>"

使用 . 来访问当前位置的上下文

使用 $ 来引用当前模板根级的上下文

使用 $var 来访问创建的变量

{{"string"}} // 一般 string
{{`raw string`}} // 原始 string
{{'c'}} // byte
{{print nil}} // nil 也被支持

Beego 中支持直接载入文件模板
{{template "path/to/head.html" .}}

使用函数
this.Data["html"] = "<h3>这是标题3</h3>"

{{str2html .html}}
{{.pipe | htmlquote }}

 
搭建sqlite3服务器环境到beego中
在models文件中：
    package models

    import (
        "os"
        "path"
        "time"
        对象关系映射，可以用来进行对数据库的各种操作。
        "github.com/astaxie/beego/orm"
        
这个是 sqlite3的数据库的驱动文件，只需执行里面的init方法即可，安装这个驱动的前提是系统安装好gcc编译器
        _ "github.com/mattn/go-sqlite3"
    )

    const (
    定义数据库文件的存放路径
        _DB_NAME        = "data/beeblog.db"
定义驱动的名字 
        _SQLITE3_DRIVER = "sqlite3"
    )

    一张表，对应一个struct结构体，里面是字段
    type Category struct {
        Id              int64
        Title           string
        Created         time.Time `orm:"index"`
        Views           int64     `orm:"index"`
        TopicTime       time.Time `orm:"index"` //设置索引
        TopicCount      int64
        TopicLastUserId int64
    }

    type Topic struct {
        Id              int64
        Uid             int64
        Title           string
        Content         string `orm:"size(5000)"`
        Attachment      string
        Created         time.Time `orm:"index"`
        Updated         time.Time `orm:"index"`
        Views           int64     `orm:"index"`
        Author          string
        ReplyTime       time.Time `orm:"index"`
        ReplyCount      int64
        ReplyLastUserId int64
    }

    定义一个初始化数据库和表的函数
    func RegisterDB() {
    
    创建数据库文件的目录结构及文件
        if _, err := os.Stat(_DB_NAME); os.IsNotExist(err) {
        //如果_DB_NAME不存在，执行到此处
        //  递归创建数据库文件的父级目录，参数2
            os.MkdirAll(path.Dir(_DB_NAME), os.ModePerm)
            os.Create(_DB_NAME) //创建数据库文件
        }
//通过orm注册模型实例，注意传的是指针
        orm.RegisterModel(new(Category), new(Topic))
        
        //注册数据库，default是必须的，类型，路径，最大连接数
        orm.RegisterDataBase("default", _SQLITE3_DRIVER, _DB_NAME, 10)
    }

main文件中
    package main

    import (
        "myproject/models"
        _ "myproject/routers"

        "github.com/astaxie/beego/orm"

        "github.com/astaxie/beego"
    )

    func init() {
        models.RegisterDB()
    }
    func main() {
        orm.Debug = true //开启orm调试
        //同步数据库 
        orm.RunSyncdb("default", false, true)
        beego.Run()
    }





















  
    

学习进度：web3
