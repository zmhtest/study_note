静态属性与静态方法：

PHP中类和函数在内存中只有一个，静态属性是类级别的属性，所以内存中也是只有一个，可以通过类名来直接访问而不需要对象的存在！！！
访问方式：Human::head

静态属性只有一个，一个对象的静态属性受影响后其他基于这个类的所有对象的静态属性也会受到影响！！！

静态方法：
普通方法存放于类内，只有一份，静态方法也是存放于类内，也是只有一份
两者的区别是：普通方法需要对象去调用($this->xxx()),但是静态方法不属于某个对象，所以静态方法不需要去绑定某个对象，直接使用类名调用(Human::foo())！！！

类是静态的，对象是动态的，动可以访问静，静不能访问动。

self parent讲解：
self和parent是类级别的！
self：本类，自身
parent：父类
所以他们可以直接调用静态方法，通过 :: 来调用。

引入self的好处就是，在需要改变类名时,只需要改变外面的类名而无需改变内部的类名。

到底是用 $this 还是用 parent 来调用父类的方法呢？
答：继承过来的就是自己的，一般使用$this来调用，除非是明确调用父类的私有属性，此时可以使用parent调用。

单例模式：
适用场景：多人开发，只创建一个对象。
注意：克隆出来的对象是一个新的对象。
思路：使用protected把类的构造方法封装起来，类内部使用 static 方法进行new对象，对象返回在类的一个static属性中，在这个过程中需要进行判断（
if($ins instanceof $single)
	{return $ins}
self::$ins = new self();
return self::$ins;	

），为了防止继承破坏单例模式，还需要在类的构造方法前加final，表示该方法不能改变。
代码：
	class single{
		public $hash = null;//随机码
		static protected $ins = null;
		final protected __construct(){
			$this->hash = mt_rand(1,99999);
		}
		static public function getInstance(){
			if(self::$ins instanceof self){
				return self::$ins;
			}

			self::$ins = new self();
			return self::$ins;
		}
	}

魔术方法：
在某些情况下会自动调用的方法。
常用的魔术方法：

__call()：调用一个不可见或者不存在的方法时，自动调用。

__callstatic()：调用一个protected、private方法时，自动调用。

__get()：获取一个不可见或者不存在的属性时，会自动调用。

__set()可以有两个参数，分别是属性和属性值

__isset()： 使用isset()函数进行判断，如果真的没有或者不可见（protected、private）这个属性，就会调用这个魔术方法。
但是，需要注意的是，如果这个函数return 1;无论isset()函数本身是否为真，返回的都是真，所以不能充分信任这个isset()的返回值。

__clone()：调用 clone()函数时，会自动调用这个函数。

__unset()：当使用unset()函数销毁一个不可见或者不存在的属性时，会自动调用__unset()函数进行处理。

代码部分：
	class Human{
		private age;
		public function __get($property){
			echo '你想调用我的',$property,'属性';
			//这个$property就是我们想获取的属性，实际上是没有的！
		}
	}

$zmh = new Human();
echo $zmh->salary;

结果：你想调用我的salary属性

准确来说：应该是调用不可见的属性时就会自动调用__get()方法。
比如：protected、private、不存在的属性

通过__set()方法，把属性的设置都放到一个数组里，处理时，直接处理这个数组就可以了，就不会对其原有的属性造成冲突了！！！

重写与重载：
重写即是子类覆盖父类的同名函数，重载是Java的，就是同名函数但是不同参数，可以同时存在，然而PHP中不允许有同名函数。

func_get_args();//在函数内部使用时，得到函数参数的个数。

类常量：专门在类内发挥作用的常量。
其实就是不可改变的静态属性。
语法：用 const AAA = 'BBB';声明。
前面不加任何修饰符。权限是public
直接用类名来调用：Class::AAA

define定义的常量是全局有效的，无论是页面内，函数内，类内都是可以正常访问的。

魔术常量：
不可改变的，但是又随环境变动的。

__FILE__这个文件的绝对路径
__DIR__当前在什么目录下
__CLASS__类名
__FUNCTION__函数名
__LINE__返回当前代码的行号，在框架中可以用来记录错误的行号信息。
__METHOD__返回当前的方法名。

后期绑定、延迟绑定
就是使用 static::foo() 在父类中调用子类的foo()方法，如果用的是self::foo(),则调用的确实是父类的foo()方法！！！

场景就是：子类对象调用一个子类没有而父类有的方法（这个方法里面又有 self::foo()或者是static::foo()）
这个self指的是父类。

抽象类：
类前加abstract

抽象方法
方法前加abstract

抽象类不能实例化，可以继承，进一步实现抽象类中的抽象方法。
抽象方法不能有方法体

抽象类的子类可以是抽象类，也可以是非抽象的。

有抽象方法，此类必须是抽象类；
抽象类内部不一定全部都是抽象方法！
可以有普通方法。

抽象类的使用方法：通过一系列的抽象方法，定义一系列的规范，然后通过子类继承这个抽象类并且实现这个抽象类的所有抽象方法，最后通过具体了的子类来new对象。

接口：功能的抽象
接口之间是可以继承的。
最后的类中，一定要把所有的抽象方法都实现才能new对象。

接口不能有属性！！！
接口只是一堆方法的说明。

类的自动加载：
利用__autoload($class)魔术方法，当new一个不存在的类时就会自动调用这个函数，并把类名传到这个函数中，然后在__autoload($class)函数里面require(''.class.'.php');引入需要加载的类！！！

类声明是全局有效的，不管在多深的函数内。

函数内可以写任何合法的PHP代码，包含再声明一个函数/类。

可以使用 spl_autoload_register('autoload');
函数将 autoload注册为自动加载函数。

异常处理：

 在类内部有可能出现异常的地方，new Exception('错误信息',错误代号)，然后抛出，throw $e;

 在new对象时，用
 try{
   
 }catch(Exception $e){
 	$e->getMsg();
 	$e->getLine();
 }

如果里面throw了Exception，外面没有捕捉，是会报错的。

























学习进度：132
























