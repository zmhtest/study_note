python基础

列表操作
	list.pop(index) #删除指定索引的元素

	list.pop() 删除最后一个并返回

	list.remove("内容") #只会删除找到的第一个

	del list[index] #注意,del 不是一个函数
	也可以使用del()函数来实现

	list.clear() #清空列表,变成 []

	dict.clear() 清空一个字典

	降序排列:
	l.sort(reverse=True)

	升序排列
	l.sort()

	反转 仅仅是翻转，并不是降序
	l.reverse()

元祖和列表是可以相互转化的
	list(tuple) #元祖转列表
	tuple(list) #列表转元祖

元祖一旦定义好，往往不能修改，如果需要修改，先转列表，然后修改，最后再次转为元祖

元祖的组包和拆包
	name = "李露露"
	age = 24
	info = name,age  #组包

	In [34]: type(info)
	Out[34]: tuple

	In [35]: info
	Out[35]: ('lilulu', 23)

	# 解包
	In [36]: hername,herage = info

	In [37]: hername
	Out[37]: 'lilulu'

	In [38]: herage
	Out[38]: 23		

--------------

	字典.setdefault(键，数据)	键值对不存在，添加键值对；存在则不做处理
	
	字典.update(字典2)	取出字典2的键值对，键值对不存在，添加键值对；存在则修改值 （用的很少）

	dict.keys()

	dict.values() 

	dict.items() #返回这种形式的数据 [(key1,value1),(key2,value2),(key3,value3)]

	字典的遍历：
	for temp in dict.values():
		print(temp)

	for temp in dict.keys():
		print(temp)

	for temp in dict.items():
		print(temp)

---------------

	特殊的切片操作：
	In [6]: str2=[1,2,3,4,5,6]

	# 默认由前往后取，步长为1
	In [12]: str2[1:3]
	Out[12]: [2, 3]

	# 从后往前取所有 【起始位置：终止位置：方向】
	In [7]: str2[::-1]
	Out[7]: [6, 5, 4, 3, 2, 1]

	# 终止位置是开区间的
	In [8]: str2[:2:-1]
	Out[8]: [6, 5, 4]

	# 从起始位置往前取
	In [9]: str2[2::-1]
	Out[9]: [3, 2, 1]

	# 从后往前 隔一个取一个
	In [10]: str2[::-2]
	Out[10]: [6, 4, 2]

-----------

字符串操作

	In [22]: str1
	Out[22]: 'hello lilulu love you very much'

	# str.partition('分割字符') 返回的是一个元祖
	In [23]: str1.partition('love')
	Out[23]: ('hello lilulu ', 'love', ' you very much')

	# 将字符串切成列表
	In [24]: str1.split()
	Out[24]: ['hello', 'lilulu', 'love', 'you', 'very', 'much']

	str.find('love') # 返回找到的索引，没找到返回 -1 不会报错

	str.index('love') # 如果找不到则会报错

	str.replace("old","new",替换的次数) # 返回替换后的字符串，并不会修改原来的字符串
	如果不加第三个参数，默认是全部替换！

运算符在高级变量中的使用：

  + 合并 字符串 列表 元祖 

	In [51]: t1 = (1,2)

	In [52]: t2 = (3,4)

	In [53]: t1+t2
	Out[53]: (1, 2, 3, 4)

	In [54]: l1 = [1,2]

	In [55]: l2 = [3,4]

	In [56]: l1+l2
	Out[56]: [1, 2, 3, 4]

  * 重复 字符串 列表 元祖 

  	In [60]: t1*3
	Out[60]: (1, 2, 1, 2, 1, 2)

	In [61]: l1*3
	Out[61]: [1, 2, 1, 2, 1, 2]

  in 和 not in 字符串 列表 元祖 
  	In [79]: 'love' in str
	Out[79]: True

  	In [62]: 1 in t1
	Out[62]: True

	In [63]: 1 in l1
	Out[63]: True

集合：无序性 唯一性
	In [75]: set={1,2,1,2}

	In [76]: set
	Out[76]: {1, 2}

忽略转义字符，原样输出：r'\n\r\t'
	In [81]: print(r'c:\come\name')
	c:\come\name

第七天 函数高级
	
	全局变量:在全局范围内,包括函数内部都可以访问,但是在函数内部不能修改

	局部变量:作用于变量定义处一直到函数结束,若函数中出现和全局同名的变量,全局变量被覆盖,只能访问到函数内部的局部变量


列表推导式:
	In [6]: a =[x for x in range(10)]

	In [7]: a
	Out[7]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

	In [8]: a =[x for x in range(10) if x % 2==0]

	In [9]: a
	Out[9]: [0, 2, 4, 6, 8]

	# 迭代决定列表的长度
	In [6]: a =[x**2 for x in range(10)]
	In [11]: a
	Out[11]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

	产生一个随机列表:
	a =[random.randint(1,10) for x in range(5)]

	In [13]: import random

	In [14]: a =[random.randint(1,5) for x in range(5)]

解决 Python2 和 Python3 共存问题:

	重新安装pip 
	cmd没打开管理员模式
	python3 -m pip install --upgrade pip --force-reinstall

	重新安装ipython
	pip3 install ipython --force-reinstall

异常:
	BaseException -> Exceptinon(常规异常的基类) -> 

案例:
	# 按照不同的异常类别进行异常的捕捉
	
# 1. 基本的处理结构是try...excpet 异常类型名称
	# 2. 异常会向上传递，若自己定义的try...except结构没有处理该异常，会将该异常传递给解释器
	try:
	    print(n)
	    print("try结构后续的内容...") # 如果上一句出现了异常,会被except捕捉,程序不会执行到此句

	# 通常会在except后跟一个需要本分支捕捉的异常类型名称, as后面跟一个普通的变量名称e
	# except中可以通过e显示具体的异常信息
	except IndexError as e1:
	    print("catch IndexError exception",e1)

	except ValueError as e2:
	    print("catch ValueError exception:", e2)

	except TypeError as e3:
	    print("catch TypeError exception",e3)

	except NameError as e4:
	    print("catch NameError exception",e4)

	except Exception as e: # 除了以上异常类,但又是属于Exception类
	    print("other exceptions:",e)

	# except : # 所有的异常类,也就是 BaseException 类
	#     print("baseexceptions:")


	# 异常未发生时执行else分支
	else:
	    print("未发生异常")

	# finally不论是否发生异常都会执行
	finally:
	    print("无论如何都被执行")



	# 如果什么异常都没有发生:
	# n
	# try结构后续的内容...
	# 未发生异常
	# 无论如何都被执行

	# 如果 print(n) n没有定义
	# other exceptions: name 'n' is not defined
	# 无论如何都被执行

	# except ValueError as e2: # 像这样打印异常对象,会直接打印这个异常后面的错误提示信息
	#     print(e2)



模块中的 print() 会在 import时,自动执行!!!

模块文件首行设置:
	__all__ = ['顶层标识']
	用于使用 from 模块 import  *
	只能导入列表中定义的标识

方法1:

Python3的包中可以没有 __init__.py文件,但是如果想通过以下方法使用,需要有
__init__.py文件,并且在该文件中写
from . import 模块1名
from . import 模块2名

import 包名 
包名.模块名.变量名/函数名/类名

推荐使用: 使用 . 分割目录或模块
方法2:包目录下不需要 __init__.py文件
	
	from 包名.模块名 import *
	还可以写成:
	from 包名 import 模块

	print(模块.标识)








学习进度： 